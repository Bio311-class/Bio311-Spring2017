---
title: "Clustering in R, Part II"
author: "Paul M. Magwene"
date: "21 February 2017"
output:
  html_document:
    toc: true
    toc_depth: 2
    theme: readable
    highlight: default  
    fig_width: 5
    fig_height: 3.25
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, prompt = FALSE, eval = TRUE, 
                      comment=NA, warning = FALSE, results="hide",
                      message = FALSE, cache = TRUE)
```


# Libraries

First load some of the generically useful R packages we've been employing.

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)
library(RColorBrewer)
```

The following libraries are specifically helpful in the context of clustering:

```{r}
library(dendextend) # for working with dendrograms
library(gplots)  # for heatmaps
```

# Load the data

As we have in previous class sessions we'll continue to illustrate our analyses using the gene expression data from Spellman et al.

```{r}
spellman <- read.csv("spellman-reformated.csv")
spellman.long <- gather(spellman, gene, expression, -time, -expt) 
```


# Combining clusters and correlation matrix heatmaps

Let's return to the subject of visualizing and evaluating clusters generated by one or more clustering algorithms.  How do we know if we have a sensible clustering?  There are many criteria -- biological, mathematical, computational -- one might apply to answer such a question, but for now let's consider the idea that a good clustering is one that produces "natural groups" in data.  In the lecture slides on clustering (see class wiki), I proferred the following "common sense" definition of natural groups:  

Natural Groups

: Groups of objects where the similarity between objects is higher within groups than between groups.

How might we evaluate a proposed clustering with respect to this definition of natural groups?  One way to do so is the examine our matrix of similarity according to the implied clusters to see if the clusters are consistent with high within group similarity and low between group similarity.

In the clustering applications we've looked at so far, our measure of similarity has been based on correlations.  We'll first look at the "raw" correlation matrix, unsorted with respect to the implied clusterings, and then we'll take a look at the correlation matrix sorted by hierarchical clustering and then k-medoids clustering.

## Visualizing a "raw" correlation matrix

We generate the correlation matrix, dropping the non-gene variables:
```{r}
# drop time and expts cols and calculate correlation matrix
spellman.cor <- 
  spellman %>% 
  select(-time, -expt) %>% 
  cor(use = "pairwise.complete.obs")
```

And then use the `heatmap.2` function (in `gplots`) to visualize the matrix. 

```{r, fig.width = 8, fig.height = 8}
color.scheme <- rev(brewer.pal(10,"RdBu")) # generate the color scheme to use

heatmap.2(spellman.cor, 
          Rowv = NULL, # don't cluster rows
          Colv = NULL, # don't cluster columns
          dendrogram = "none", # don't draw dendrograms
          trace = "none", density.info = "none", 
          col = color.scheme, keysize  = 1,
          labRow = FALSE, labCol = FALSE,
          xlab = "genes", ylab = "genes")
```

A correlation matrix is a square symmetric matrix.  The dark red line down the diagonal represents correlations of genes with themselves (i.e. perfectly correlated).  Off diagonal elements range from blue (negative correlations) to gray (near zero correlations) to red (positive correlations).

## Hierarchical clustering, visualized on correlation matrix

Now let's carry out hierarchical clustering on this data set, using 1 - correlation as the measure of dissimilarity, and the complete linkage methods.

```{r}
spellman.dist <- as.dist(1 - spellman.cor) 
spellman.tree <- hclust(spellman.dist, method="complete")
spellman.dend <- as.dendrogram(spellman.tree)
```

With the clustering in hand, we then re-generate the heatmap of the correlation matrix with the genes sorted by the implied clustering and the dendrograms drawn to the sides as well.

```{r, fig.width = 8, fig.height = 8, fig.align="center"}
heatmap.2(spellman.cor, 
          Rowv = ladderize(spellman.dend), 
          Colv = ladderize(spellman.dend), 
          dendrogram = "both", 
          revC = TRUE,  # rev column order of dendrogram so conforms to natural representation
          trace = "none", 
          density.info = "none",
          col = color.scheme, key = FALSE,
          labRow = FALSE, labCol = FALSE)
```

This reordered correlation matrix (and accompanying dendrograms) are useful for a number of purposes.  First, the block structure along the diagonal indicates the correlation structure within the implied clusters. Uniformity in sign and magnitude of the on-diagongal blocks is an indicator of "within cluster" similarity.  The off-diagonal blocks indicate the relationship *between clusters*.  For example, the four "major" clusterings implied by the dendrogram are apparent in the block structure of the correlation matrix, but we also see that the two clusters at the bottom of the figure show some patches of weak or even negative correlations, suggesting that those may not be natural clusters.  Also apparent are relationships between clusters -- for example we see that genes in the first cluster (upper left of diagram) share strong positive correlations with many genes in the right half of the second cluster.  The same relationship, though to a lesser extant, is apparent between clusters one and four.


## K-medoids clustering visualized on the correlation matrix

Let's do a similar sorting of the correlation matrix based on k-medoids clustering.  We'll apply the `pam` function for k-mediods, asking for $k = 8$ clusters.

```{r}
library(cluster)
spellman.kmedoids <- pam(spellman.dist, 8) # create k-medoids clustering with 8 clusters
kclusters <- spellman.kmedoids$cluster
```

Since there is no dendrogram to pass to the `heatmap.2` function, we'll sort the correlation matrix ourselves by indexing on return the output of the `order` function applied to the cluster assignments (read the `order` function help for more info).

```{r}
# reorder correlation matrix by ordering given by clustering
kmedoids.cor <- spellman.cor[order(kclusters),order(kclusters)]
```

Having reordered the correlation matrix by the k-clusters, we can again use the `heatmap.2` function to visualize the results.

```{r, fig.width=8, fig.height=8}
heatmap.2(kmedoids.cor, Rowv = NULL, Colv = NULL, 
          dendrogram = "none", 
          trace = "none", density.info = "none",
          col = color.scheme, key = FALSE,
          labRow = FALSE, labCol = FALSE)
```

The diagram has the same interpretation as the previous figure.  However, here we notice that the clusters seem to be more internally consistent, as evidence by the greater within cluster uniformity of correlations.  Positive and negative relationships between clusters are also readily apparent in this figure.


# Sorting genes by time of maximum expression

Clustering isn't the only criterion we might want to use to organize information about gene expression.  For example, in a time series data one might be interested in examing genes with respect to some property of their dynamic expression. Here we'll sort the data from the alpha factor synchronization experiment by time of maximum expression.

To do this we'll emply the function `which.max` (`which.min`), which finds the index of the maximum (minimum) element of a vector.

```{r}
alpha.factor <- filter(spellman, expt == "alpha")
which.max(alpha.factor$YAL022C)
```

From the code above we find that the index of the observation at which YAL022C is maximal is 18.  To get the corresponding time point we can do something like this:


```{r}
alpha.factor$time[which.max(alpha.factor$YAL022C)]
```

Thus YAL022C expression peaks at 119 minutes in the alpha factor experiment.


To find the index of maximal expression of all genes, let's first convert the alpha factor data frame to the "long format" and then apply the `group_by` and `summarise` functions from dplyr:

```{r}
alpha.factor.long <- filter(spellman.long, expt == "alpha")

peak.expression <- alpha.factor.long %>% 
           group_by(gene) %>% 
           summarise(peak = which.max(expression))
```

We can then generate a heatmap where we sort the rows (genes) of the heatmap by their time of peak expression.  For variety, I decided to do this in ggplot rather than with the `heatmap.2` function.  I introduce a new geom -- `geom_raster` -- which is like `geom_tile` but better suited for large data.  The explicit sorting of the data is carried out in the call to `scale_y_discrete` where the limits (and order) of this axis are set with the `limits` argument (see `scale_y_discrete` and `discrete_scale` in the ggplot2 docs).

```{r, fig.height = 6, fig.width = 4, fig.cap = "A Heatmap showing genes in the alpha-factor experiment, sorted by peak expression", fig.align="center"}
alpha.factor.long %>%
  ggplot(aes(x = time, y = gene)) +
  geom_raster(aes(fill = expression)) +  # 
  scale_fill_gradientn(limits=c(-2,2),colors=color.scheme) +
  scale_y_discrete(limits=peak.expression$gene[rev(order(peak.expression$peak))]) + 
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())
```

