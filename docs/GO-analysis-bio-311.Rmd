---
title: "Gene Function Analysis in R"
author: "Paul M. Magwene"
output:
  html_document:
    toc: true
    toc_depth: 2
    theme: readable
    highlight: default  
    fig_width: 5
    fig_height: 3.25
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, prompt = FALSE, eval = TRUE, 
                      comment=NA, warning = FALSE, results="hide",
                      message = FALSE, cache = TRUE)
```


# New Packages to install

First we'll install a package called "gProfileR", which provides an R interface to a web-based gene function tool called [g:Profiler](http://biit.cs.ut.ee/gprofiler/). We can install this via the standard package install mechanism:

```{r, eval = FALSE}
install.packages("gProfileR", dependencies = TRUE)
```

## Bioconductor packages

We'll also be installing some new packages that are part of a larger library of R tools called [Bioconductor](https://bioconductor.org). Bioconductor contains many different packages for helping to carry out bioinformatics tasks of various kinds. 

To make the Bioconductor packages accesible, first evaluate this code:

```{r, eval=FALSE}
source("https://bioconductor.org/biocLite.R")
```

Having done so, you can now use the `biocLite` function to install Bioconductor packages. The `biocLite` function will also install other Bioconductor packages as necesary.

Let's start with an annotation database that contains information about genes in the genome of *Saccharomyces cerevisiae*, the common budding yeast we've been working with throughout our examples.

NOTE: You may get a prompt about updating some of the other libraries that are currently installed in your R instance.  You should answer "No" (or "none") to the question about updating, as the updates will also take a long time to install and don't change key functionality that is relevant to the analyses you will undertake.

```{r, eval=FALSE}
biocLite("org.Sc.sgd.db")
```

Let's also install a tool called "GOsummaries" which provides some userful visualizations of GO searches based on gProfileR.  

```{r, eval=FALSE}
biocLite("GOsummaries")
```




# Other Libraries

Here are some of the other libraries we've used in past analyses, and will continue to exploit.

```{r,warning=F,message=F}
library(dplyr)
library(tidyr)
library(ggplot2)
library(dendextend)
library(RColorBrewer)
library(cluster)
```


# Creating a clustering

We'll need some gene clusters to work with. If you saved your workspace from previous days, you can use one of the clusterings you've already created. If not, here's a quick reminder on the steps for carrying out hierarchical clustering, using the "complete linkage" method, with the now familiar Spellman data set.

```{r}
spellman <- read.csv("spellman-reformated.csv")
spellman.cor <- spellman %>%  dplyr::select(-time, -expt) %>% cor(use = "pairwise.complete.obs")
spellman.clust <- hclust(as.dist(1 - spellman.cor), method="complete")
spellman.dend <- as.dendrogram(spellman.clust)
```

# Cutting dendrogram at a given height

In past lectures we've created dendrograms and then asked for certain number of clusters. Alternatively, we can cut the dendrogram at a given height, and get the subtress that are returned:

```{r,message=FALSE,warning=FALSE, fig.width = 8, fig.height = 6}
color.dend <- color_branches(spellman.dend, h=1.3, col=brewer.pal(8,"Dark2"))
plot(color.dend, leaflab = "none")
```

Visually the clusters look fairly reasonable, though cluster 3 (the big purple cluster in the figure you generated) looks particularly large and there's pretty clear sub-structure that might be worth exploring in more detail.  For now, we'll continue using the clusterings generated by cutting the tree at height = 1.3.

```{r}
clusters <- cutree(color.dend, h = 1.3, order_clusters_as_data = FALSE)
subtrees <- cut(color.dend, h = 1.3)
sort(table(clusters),decreasing = TRUE)  # get the cluster sizes 
```
By specifying `order_clusters_as_data = FALSE` we insure that the clusters and corresponding subtrees match. The last line show the clusters sorted by size.  Cluster 3 is the largest, with 169 genes; Cluster 5 is the smallest with 14 genes.


# From clusters to sets of gene names

Let's now get the lists of genes in each cluster.  We saw last class that we could extract a list of labels from subtrees returned by  `cut`  using the `labels` function:

```{r}
labels(subtrees$lower[[1]])
```

However, typing all that text every time we want to look at cluster is a little tedious, so we're going to use a function called `lapply` to extract our gene names for all the subtrees at once. `lapply` applies a given function to all the elements of a list.

```{r}
gene.clu <- lapply(subtrees$lower, labels)
```

Now we can get the genes in each cluster like so:

```{r}
gene.clu[[5]] # get cluster 5 genes
```

# Using the AnnotationDbi functions

When we loaded the "org.Sc.sgd.db" package it also automatically loaded a packaged called "AnnotationDbi".  AnnotationDbi provides functions for working with gene annotation databases like "org.Sc.sgd.db".

## Loading the library

You can load Bioconductor libraries just like any other R library:

```{r,message=FALSE,warning=FALSE,cache=FALSE}
library(org.Sc.sgd.db)
```


## Basic Info about our Annotation Database

First, let's look at some basic AnnotationDbi functions that provide info about the database we're working with.

`columns` provides a list of all the fields (columns) of our annotation database:

```{r}
columns(org.Sc.sgd.db)
```

We see that there are 24 field in the yeast database.  For example, the "ORF" field gives standard systematic gene names (e.g. YAL022C) while the "COMMON" field gives the common name that the gene is usually referred to in the literature.  "ALIAS"  gives other names that the gene might be referred to in the literature as well (before genome sequencing was ubiquitous, it was not uncommon for multiple labs to isolate the same gene in different genetic screens, and use different names depending on the phenotype or trait they were studying).

## Looking up data using `select` from an annotation database

Let's use the AnnotationDbi function `select` to explore a few genes.  

NOTE:  the dplyr package also defined a `select` function.  When we imported the AnnotationDbi package, that packaged "masked" the dplyr function of the same name.  If we still want to use the dplyr `select` function we can prepend the function name with the package name like so `dplyr::select` (`dplyr::filter` and some other functions are also affected).

First we'll get the aliases for the gene designated YAL022C:

```{r}
select(org.Sc.sgd.db, "YAL022C", "ALIAS")
```

Note that `AnnotationDbi::select` returns a data frame.

The first argument to select is the database itself, followed by the genes you want to look up (by default ORFs for the Yeast database), and then the columns you want to get back.  Here we see that the only common name of YAL022C is "FUN26". Let's look up the description of FUN26:

```{r}
select(org.Sc.sgd.db, "YAL022C", "DESCRIPTION")
```

By default, `select` looks up genes by ORF name (the default keys for the Yeast database), but we can also use other designations as keys.  For example, the gene known by the common name "CYR1" is one my lab studies.  Let's look up it's ORF name:

```{r}
# using pipe operator to illustrate alternative calling scheme
org.Sc.sgd.db %>% select("CYR1", "ORF", keytype = "COMMON")
```

We can get the UniProt ID of CYR1 (UniProt is a standard database of protein information):

```{r}
org.Sc.sgd.db %>% select("CYR1", keytype = "COMMON", columns = "UNIPROT")
```

Finally, let's look up the Gene Ontology (GO) annotation associated with CYR1:

```{r}
cyr1.GO <- 
  org.Sc.sgd.db %>% select("CYR1", keytype = "COMMON", columns = "GO")

cyr1.GO
```

We see that in this case, we get back a data frame with multiple rows, as there are multiple GO terms associated with this gene.  Note too that in addition to the GO column, EVIDENCE and ONTOLOGY columns were also returned 

## Looking up multiple genes at once

The `select` function also works with multiple gene queries.  For example, to get functional descriptions of the 14 genes in Cluster 5 from our analysis above we could do:

```{r}
org.Sc.sgd.db %>% select(gene.clu[[5]], columns = "DESCRIPTION")
```

QUESTION: Take a few minutes to read the text of the descriptions associated with with Cluster 5.  Can you make an educated guess, based on this information, about the types of biological processes and cellular components Cluster 5 genes might be involved?


# Using gProfileR

The `gProfileR` package provides an R interface to the online "g:Profiler" web tools. Therefore you will need an internet connection to carry out the gene ontology searches in this section.

The key function in the gProfiler package is `gprofiler`, which takes a list of query genes, 

```{r}
library(gProfileR)

profile.5 <- gprofiler(gene.clu[[5]], 
                       organism = "scerevisiae",
                       max_p_value = 0.05,  # set p-value cutoff
                       src_filter = "GO" # only consider GO sources (see docs)
                       )
profile.5
```

`gprofiler` returns a data frame with the information about the hits from the query. From the output generated above, we see that two GO terms were found to be enriched in this cluster -- "long-chain fatty acid metabolic process" (3 genes with this label, p-value = 0.000376)  and "long-chain fatty acid biosynthetic process" (2 genes with this label, p-value = 0.01690).

`gprofiler` can also take a list of queries to carry out. For example, in the following code we carry out the gprofiler query for all the clusters we generated, restricting our results to biological process GO terms.  We also use set an argument called `hier_filtering` (hierarchical filtering) which tries to simplify the terms returned.


```{r}
all.profiles <- gprofiler(gene.clu, 
                          organism = "scerevisiae",
                          max_p_value = 0.05,  # set p-value cutoff
                          src_filter = "GO:BP", # only consider GO biological process
                          hier_filtering = "moderate")
```

The data frame returned by `gprofiler` has columns we can filter on:

```{r}
names(all.profiles)
```

For example, to restrcit our attention to cluster 8, we can filter on the "query.number" field:

```{r}
dplyr::filter(all.profiles, query.number == 8)
```

Here we see ion transport (term ID: "GO:0006811")  is one of the most enriched terms,with 16 out of 50 genes in our query have this GO label. 

## Combining gProfileR results with AnnotationDbi information

Let's see how we can extract the set of 16 genes associated with ion transport and get more detailed descriptions of what they do based on the Annotation database we introduced earlier.

```{r}
clu8.ion.transport <- dplyr::filter(all.profiles, 
                                    query.number == 8 & term.id == "GO:0006811")

clu8.ion.transport.genelist <- clu8.ion.transport$intersection
clu8.ion.transport.genelist
```

We see that the list of genes witht his term is returned as a character string, with the names separated by columns. To turn this into individual gene names we can use the `str_split` function defeined in the "stringr" package (installed by default on VM Manage, install it use R on your local machine).

```{r}
library(stringr)
clu8.ion.transport.genes <- str_split(clu8.ion.transport.genelist, ",")[[1]]
```

We can then use the `select` function in AnnotationDbi with this list:

```{r}
org.Sc.sgd.db %>% AnnotationDbi::select(clu8.ion.transport.genes, 
                                        columns = c("GENENAME", "DESCRIPTION"))
```

